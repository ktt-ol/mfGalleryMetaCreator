#!/usr/bin/env node

'use strict';

var fs = require('fs');
var path = require('path');
var util = require('util');
var log = require('verbalize');
var argv = require('minimist')(process.argv.slice(2));
var im = require('imagemagick');
var Q = require('q');
var arrayFind = require('array-find');
var async = require('async');
var SimpleIni = require('simple-ini');


/**
 * Config
 */

var CONFIG = {
  fileRegExp: /\.jpe?g$/i,
  thumbDir: '.thumbs',
  contentINI: 'content.ini',
  metaName: 'meta.json',
  maxProcessSpawns: 5
};

/**
 * Startup
 */

var ORDER = [
  'exifTimeAsc',
  'exifTimeDesc',
  'filenameAsc',
  'filenameDesc'
];

log.runner = 'mf-gallery-meta-creator';

var ARGS = {
  path: argv.p || argv.path,
  size: argv.s || argv.size,
//  coverSize: argv.c || argv.coverSize,
  order: argv.order || ORDER[0],
  forceUpdate: !!argv['force-update'] || false
};

if (!ARGS.path) {
  usage('Please specify the path to the images..');
  return;
}
if (!ARGS.size) {
  usage('Please specify at least one thumbnail size.');
  return;
}
if (ORDER.indexOf(ARGS.order) === -1) {
  usage('Invalid value for ´order´.');
  return;
}


// make an array if isn't already
if (!util.isArray(ARGS.size)) {
  ARGS.size = [ ARGS.size ];
}


/**
 * Application
 */

// a task for the imaging processes. If we don't limit the max concurrent process spawns, we run into the ulimit
var imQueue = async.queue(function (task, callback) {
  if (task.type === 'identify') {
    im.identify(task.param, function (err, data) {
      task.callback(err, data);
      callback();
    });
  } else if (task.type === 'resize') {
    im.resize(task.param, function (err, data) {
      task.callback(err, data);
      callback();
    });
  } else {
    callback('invalid task type: ' + task.type);
  }
}, CONFIG.maxProcessSpawns);

function usage(hint) {
  log.writeln(log.bold('Usage:'));
  log.writeln('\t-p or --path= \t\t\tthe path to images');
  log.writeln('\t-s or --size= \t\t\tthe bounding box of the thumbnails. You can use this parameter more than once.');
  log.writeln('\t--order=' + ORDER.join('|'));
  log.writeln('\t\tdefault is '+ ORDER[0]);
  log.writeln('\t--force-update\t\t\tignores the existing ' + CONFIG.metaName + ' files.');
//  log.writeln('\t-c or --coverSize=\t\t\ta size especially for the cover images');
  log.writeln('');
  log.writeln(log.bold('Example:'));
  log.writeln('\t-p dir1/dir2/dir3 -s 150 -s 300');
  log.error(hint);
}

var orderFunctions = {
  exifTimeAsc: function (a, b) {
    var timeA = (a.exif && a.exif.time) || Number.MAX_VALUE;
    var timeB = (b.exif && b.exif.time) || Number.MAX_VALUE;

    var diff = timeA - timeB;
    if (diff !== 0) {
      return diff;
    }

    return a.name.localeCompare(b.name);
  },

  exifTimeDesc: function (a, b) {
    var timeA = (a.exif && a.exif.time) || Number.MAX_VALUE;
    var timeB = (b.exif && b.exif.time) || Number.MAX_VALUE;

    var diff = timeB - timeA;
    if (diff !== 0) {
      return diff;
    }
    return a.name.localeCompare(b.name);
  },

  filenameAsc: function (a, b) {
    return a.name.localeCompare(b.name);
  },

  filenameDesc: function (a, b) {
    return b.name.localeCompare(a.name);
  }
};

function readFolder(baseFolder) {

  var readMetaPromises = [];

  function readFolderInternal(folder) {

    var content = {
      fullPath: folder,
      name: path.basename(folder),
      meta: {},
      files: [],
      folder: [],
      //
      prevImages: []
    };

    fs.readdirSync(folder).forEach(function (name) {

      // skip .xxxx folder/files
      if (name.indexOf('.') === 0) {
        return;
      }

      var fullName = folder + '/' + name;
      var stat = fs.statSync(fullName);

      if (stat.isDirectory()) {
        content.folder.push(readFolderInternal(fullName));
        return;
      }

      if (name === CONFIG.contentINI) {
        log.info('Content INI file found in ', folder);
        content.meta = readINIFile(fullName);
      }


      if (!ARGS.forceUpdate && name === CONFIG.metaName) {
        log.writeln('Previous generated meta file found in ', folder);
        readMetaPromises.push(
          readJsonFile(fullName).then(
            function ok(prevGenMeta) {
            content.prevImages = (prevGenMeta && prevGenMeta.images) || [];
          }, function error(err) {
              log.info('Error in json file "' + fullName + '": ', err);
            })
        );
      }

      if (!CONFIG.fileRegExp.test(name)) {
        return;
      }

      content.files.push(name);
    });

    return content;
  }

  var result = readFolderInternal(baseFolder);

  return Q.all(readMetaPromises).then(function () {
    return result;
  });
}


/**
 * @param filename
 * @returns {promise} with parsed meta info object
 */
function readJsonFile(filename) {
  var deferred = Q.defer();
  fs.readFile(filename, function (err, data) {
    if (err) {
      deferred.reject('Could not read json file "' + filename + '": ' + err);
      return;
    }

    try {
      var info = JSON.parse(data.toString());
      deferred.resolve(info);
    } catch (e) {
      deferred.reject('Unable to parse the json file "' + filename + '": ' + e);
    }
  });

  return deferred.promise;
}

function readINIFile(filename) {
  var config = new SimpleIni(function() {
    return fs.readFileSync(filename, 'utf-8');
  }, {
    processOptions: [';', '#'],
    ignoreWhitespace: true
  });
  var writableConfig = {};
  for (var key in config) {
    if (config.hasProperty(key)) {
      writableConfig[key] = config.get(key);
    }
  }

  return writableConfig;
}

function resizeImage(src, target, size) {
  var resizeParam = {
    srcPath: src,
    dstPath: target,
    width: size,
    height: size,
    customArgs: [
      // http://www.imagemagick.org/script/command-line-options.php?#resize
      // adjusts an image so that its orientation is suitable for viewing (i.e. top-left orientation).
      '-auto-orient'
    ]
  };

  var deferred = Q.defer();
  imQueue.push({
    type: 'resize',
    param: resizeParam,
    callback: function (err, stdout, stderr) {
      if (err) {
        deferred.reject(err);
        return;
      }
      log.info('Thumbnail created:', size, target);

      deferred.resolve('resized', target);
    }});

  return deferred.promise;
}

/**
 *
 * @param path
 * @param imageFile
 * @returns {Array of Promise}
 */
function createThumbnailsForImage(dirContent, imageFile) {
  var srcImage = dirContent.fullPath + '/' + imageFile;
  var thumbDirPath = dirContent.fullPath + '/' + CONFIG.thumbDir;

  function resize(size) {
    var target = util.format('%s/%d-%s', thumbDirPath, size, imageFile);

    if (fs.existsSync(target)) {
      log.info('Thumbnail exists:', size, target);
      return promises;
    }

    if (!fs.existsSync(thumbDirPath)) {
      fs.mkdirSync(thumbDirPath);
    }

    promises.push(
      resizeImage(srcImage, target, size)
    );
  }

  var promises = [];
  ARGS.size.forEach(resize);

  return promises;
}

// function copied from the imagemagick nodejs lib
function ExifDate(value) {
  // YYYY:MM:DD HH:MM:SS -> Date(YYYY-MM-DD HH:MM:SS +0000)
  value = value.split(/ /);
  return new Date(value[0].replace(/:/g, '-') + ' ' +
    value[1] + ' +0000');
}

/**
 *
 * @param dirContent
 * @param imageFilename
 * @returns {promise}
 */
function readSomeExifData(dirContent, imageFilename) {

  var result = {
    path: dirContent.fullPath,
    name: imageFilename,
    width: -1,
    height: -1,
    exif: {}
  };

  var prevData = arrayFind(dirContent.prevImages, function (element) {
    return element.name === imageFilename;
  });

  if (prevData) {
    result.width = prevData.width;
    result.height = prevData.height;
    result.exif = prevData.exif;
    return Q.when(result);
  }

  var target = dirContent.fullPath + '/' + imageFilename;

  var deferred = Q.defer();
  imQueue.push({
    type: 'identify',
    param: target,
    callback: function (err, data) {
      if (err) {
        deferred.reject(err);
        return;
      }

      if (!data.width || !data.height) {
        log.warn('No width or height: ' + imageFilename);
      }

      if (!data) {
        log.warn('No metadata for ' + imageFilename);
        deferred.resolve(result);
        return;
      }

      result.width = data.width;
      result.height = data.height;

      var exif = result.exif;
      if (data.properties) {
        exif.make = data.properties['exif:make'];
        exif.model = data.properties['exif:model'];

        var timeStr =
             data.properties['exif:datetimedigitized']
          || data.properties['exif:datetimeoriginal']
          || data.properties['exif:datetime'];
        if (timeStr) {
          exif.time = new ExifDate(timeStr).getTime();
        }
      }

      // check if the image is rotated and we have to switch width/height
      // rotation help: http://www.impulseadventure.com/photo/exif-orientation.html
      var rotation = data.properties['exif:orientation'];
      if (rotation === '8' || rotation === '6') {
        var tmp = result.width;
        //noinspection JSSuspiciousNameCombination
        result.width = result.height;
        result.height = tmp;
      }

      log.info('Image metadata read:', target);

      deferred.resolve(result);
    }});

  return deferred.promise;
}

/**
 *
 * @param dirContent
 * @param imageFilesWithExif
 * @returns {promise}
 */
function writeMetafile(dirContent, imageFilesWithExif) {
  log.info('Create metadata file for ', dirContent.fullPath);

  var images = imageFilesWithExif.map(function (obj) {
    return {
      name: obj.name,
      width: obj.width,
      height: obj.height,
      exif: obj.exif
    };
  });

  // sort the image array by exif timestamp and filename as fallback
  images.sort(orderFunctions[ARGS.order]);

  var metaData = {
    meta: {
      name: dirContent.meta.name || dirContent.name,
      description: dirContent.meta.description || ''
    },
    images: images,
    subDirs: []
  };

  dirContent.folder.forEach(function (subFolderContent) {
    var subContent = subFolderContent.meta;
    subContent.folder = subFolderContent.name;
    subContent.cover = subContent.cover || subFolderContent.files[0] || null;
    metaData.subDirs.push(subContent);
  });

  var deferred = Q.defer();
  var fullFilename = dirContent.fullPath + '/' + CONFIG.metaName;
  fs.writeFile(fullFilename, JSON.stringify(metaData), function (err) {
    if (err) {
      deferred.reject('write error' + err);
      return;
    }

    deferred.resolve(fullFilename);
  });

  return deferred.promise;
}

function workOnDirContent(dirContent) {
  var readExifMetaPromises = [];

  dirContent.files.forEach(function (filename) {
    thumbnailPromises = thumbnailPromises.concat(createThumbnailsForImage(dirContent, filename));

    readExifMetaPromises.push(readSomeExifData(dirContent, filename));
  });

  var subDirPromises = [];
  dirContent.folder.forEach(function (subDirContent) {
    subDirPromises.push(workOnDirContent(subDirContent));
  });

  return Q.all(subDirPromises).then(function (/*don't care*/) {
    return Q.all(readExifMetaPromises).then(function (imageFilesWithExif) {
      return writeMetafile(dirContent, imageFilesWithExif);
    });
  });
}


/* Start here */


if (!fs.existsSync(ARGS.path)) {
  log.error('Path "', ARGS.path, '" did not exists.');
  return;
}

log.info('Reading ', ARGS.path, ' for images...');


var thumbnailPromises = [];

readFolder(ARGS.path).then(workOnDirContent).then(function (/*don't care*/) {
  return Q.all(thumbnailPromises);
}).done(
  function () {
    log.done('Done!');
  },
  function error(err) {
    log.error('We got errors: ', err);
    throw err;
  }
);
